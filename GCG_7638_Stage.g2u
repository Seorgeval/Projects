Program.Sub.ScreenSU.Start
Gui.PartForm..Create(DashForm)
Gui.PartForm..Caption("Part Lot/Bin Allocation")
Gui.PartForm..Size(1024,720)
Gui.PartForm..MinX(0)
Gui.PartForm..MinY(0)
Gui.PartForm..Position(0,0)
Gui.PartForm..AlwaysOnTop(False)
Gui.PartForm..FontName("Tahoma")
Gui.PartForm..FontSize(8.25)
Gui.PartForm..ControlBox(True)
Gui.PartForm..MaxButton(True)
Gui.PartForm..MinButton(True)
Gui.PartForm..MousePointer(0)
Gui.PartForm..Moveable(True)
Gui.PartForm..Sizeable(True)
Gui.PartForm..ShowInTaskBar(True)
Gui.PartForm..TitleBar(True)
Gui.PartForm..Event(UnLoad,PartForm_UnLoad)
Gui.PartForm..BarSaveButton(True,False)
Gui.PartForm..Event(SaveButtonClick,PartForm_SaveButtonClick)
Gui.PartForm.GsGCPart.Create(GsGridControl)
Gui.PartForm.GsGCPart.Enabled(True)
Gui.PartForm.GsGCPart.Visible(True)
Gui.PartForm.GsGCPart.Zorder(0)
Gui.PartForm.GsGCPart.Size(1024,639)
Gui.PartForm.GsGCPart.Position(0,0)
Gui.PartForm.GsGCPart.Event(CellValueChanged,GsGCPart_CellValueChanged)
Gui.PartForm.GsGCPart.Dock(5)
Gui.PartForm.GsGCPart.Event(RowCellClick,GsGCPart_RowCellClick)
Program.Sub.ScreenSU.End

Program.Sub.Preflight.Start
Program.Sub.Preflight.End

Program.Sub.Main.Start
F.Intrinsic.Control.Try
Function.Intrinsic.UI.UsePixels ' Allows you to use Pixels instead of Twips throughout

'ARC 7638
'Diversified Labeling Solutions (DLS)
'George Sandoval
'14 Aug 2024

'Script that is designed to launch on the script 1 for Order Entry > Transactions > Staging Shipments > New/Open (Open only after invoicing existing staged shipments)
'This is going to bring up another form that the user can select a lot/bin for the selected lines loaded on the grid to allocate the quantities for from the specified lot/bin.
'The purpose is for the form to do the math for us so the users can quickly select the lot/bin without having to perform any calculations if a single lot/bin does not contain enough quantity to be staged. Reduces manual mathematical errors and saves time.

'Hooks
'38401 - Order Entry > Transactions > Staging Shipments > New > Populate hook
'38402 - Order Entry > Transactions > Staging Shipments > New > Script 1 hook
'33110 - Order Entry > Transactions > Staging Shipments > New > Part Allocation Populate Hook
'33120 - Order Entry > Transactions > Staging Shipments > New > Part Allocation Script 1 Hook

'Company Options
'Use lot/bin
'Use rev
'Not compatible for long parts

'Steps
'1 - Read the BDF to see what part(s) we have on this order line selected to be staged
'2 - Load item master lot/bin based on the part number(s) from the BDF
'3 - Format the grid so that we can display the requested columns (see columns below)
'4 - Display the grid and allow the user to select the item master lot/bin and quantity to stage from this form
'5 - Save button will trigger the program to write back to the BDF to allocate quantities based on what was selected

'Columns
'Select
'Lot
'Bin
'Heat
'Serial
'Available qty on hand(in the lot/bin)
'Qty to allocate - Will populate based on logic from the quote

'If the Qty On Hand of the selected lot/bin record exceeds the quantity entered to stage, 
	'Then it should set the Qty to Alloc equal to the staged quantity that was entered on the header screen. 
'If other lot/bin records have already been selected, 
	'Then it should only take the quantity required to meet the staged quantity. (Sum of Qty to Allocate where part = selected part) - (Qty Needed to Allocate)
'If the Qty On Hand of the selected lot/bin record is less than the quantity entered to stage, 
	'Then it should default to match the Qty On Hand. 

F.Intrinsic.Control.SelectCase(V.Caller.Hook)
	'Populate hook to rename the script 1 button
	F.Intrinsic.Control.Case(33110) 
		V.Passed.000242.Set("Lot/Bin Alloc")
		F.Intrinsic.Control.End
	'Script 1 button click that launches the form to select the lot/bin for the part(s) on the grid
	F.Intrinsic.Control.Case(38402) 
		
		F.Intrinsic.Control.CallSub(ReadBDF)
		'Check to see if anything is actually loaded on the core grid
		F.Intrinsic.Control.If(V.DataTable.dtPart.RowCount, >, 0)
			F.Intrinsic.Control.CallSub(LoadData)
			F.Intrinsic.Control.CallSub(FormatGrid)
			Gui.PartForm..Show
		F.Intrinsic.Control.EndIf
		
F.Intrinsic.Control.EndSelect
F.Intrinsic.Control.End

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(Error, "Subroutine", V.Ambient.CurrentSubroutine, "ErrorDesc", V.Ambient.ErrorDescription, "ErrorNo", V.Ambient.ErrorNumber)
	F.Intrinsic.Control.EndTry
Program.Sub.Main.End

Program.Sub.ReadBDF.Start
F.Intrinsic.Control.Try

'Bring the BDF into a datatable
F.Intrinsic.BDF.Load("dtOriginal", "AUX001", True)
'Filter bring in desired rows. Criteria (These qty values are evaluated as strings for some reason)
'Selected and BO qty > 0
'Selected and BO qty =! ''
'Not selected and Staged Qty > 0
'Not selected and Staged Qty =! ''

F.Data.DataView.Create("dtOriginal", "dvSelect")
F.Data.DataView.ToDataTable("dtOriginal", "dvSelect", "dtPart", True)
F.Data.DataView.Close("dtOriginal", "dvSelect")

F.Intrinsic.Control.If(V.DataTable.dtPart.RowCount, =, 0)
	F.Intrinsic.UI.Msgbox("Please select rows to continue with the custom part allocations screen", "No Rows Selected")
	F.Intrinsic.Control.End
F.Intrinsic.Control.EndIf

'Go next to the load data sub to load item master info to display on the grid.

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(Error, "Subroutine", V.Ambient.CurrentSubroutine, "ErrorDesc", V.Ambient.ErrorDescription, "ErrorNo", V.Ambient.ErrorNumber)
	F.Intrinsic.Control.EndTry
Program.Sub.ReadBDF.End

Program.Sub.LoadData.Start
F.Intrinsic.Control.Try
V.Local.iLoop.Declare(Long)
V.Local.sSql.Declare(String)
V.Local.sFilter.Declare(String)
V.Local.sColumns.Declare(String)
V.Local.sColumnTypes.Declare(String)
V.Local.sRowIndex.Declare(String)
V.Local.fQtyStage.Declare(Float)
V.Local.sSOLine.Declare(String)

'Select
'Lot
'Bin
'Heat
'Serial
'Available qty (in the bin)
'Qty to issue/stage

'Our dtPart already has the original BDF from the screen which contains all of the lot/bin records for this part + location
'But, it doesn't have the actual part/location in the dt. We don't need it though. We just need to modify the BDF with the corresponding values

'Create an empty datatable with all of the columns we are going to fill in based on the part numbers from the grid. Item master can return different number of rows based on the part number so we can just merge with this empty datatable to fill it in easily.
V.Local.sColumns.Set("Line*!*Part*!*Rev*!*Location*!*Lot*!*Bin*!*Heat*!*Serial*!*Qty On Hand*!*Open Quantity*!*Qty Alloc From Inv*!*Qty to Alloc")
V.Local.sColumnTypes.Set("String*!*String*!*String*!*String*!*String*!*String*!*String*!*String*!*Float*!*Float*!*Float*!*Float")

F.Data.DataTable.CreateFromString("dtItems", "", V.Local.sColumns, V.Local.sColumnTypes, "*!*", "", True)

'We're going to loop through each line of the BDF.Yes, we can have the same part + same loc multiple times on a sales order. We are accounting for that by tying the SO Line to the lot/bin records on the form we are displaying

F.ODBC.Connection!con.OpenCompanyConnection
F.Intrinsic.Control.For(V.Local.iLoop, 0, V.DataTable.dtPart.RowCount--, 1)
	F.Intrinsic.String.Build("Select RTRIM(SUBSTRING(PART, 1, 17)) AS Part, RTRIM(SUBSTRING(PART, 18, 3)) AS Rev, Location, Lot, Bin, Heat, rtrim(Serial_Number) as Serial, Quantity as Qty On Hand from ITEM_MASTER where Part = '{0}' and Location = '{1}'", V.DataTable.dtPart(V.Local.iLoop).Part Number!FieldVal, V.DataTable.dtPart(V.Local.iLoop).Loc!FieldVal, V.Local.sSql)
	F.Data.DataTable.CreateFromSQL("dtMerge", "con", V.Local.sSql)
	F.Data.DataTable.AddColumn("dtMerge", "Line", "String")
	F.Data.DataTable.AddColumn("dtPart", "Open Quantity", "Float", 0.0)
	F.Data.DataTable.AddColumn("dtMerge", "Qty Alloc From Inv", "Float", 0.0)
	F.Data.DataTable.AddColumn("dtMerge", "Qty to Alloc", "Float", 0.0)

'	'We need the qty to allocate from the BDF for each row so we need to set that here to our new datatable
'	'Have the row for the original BDF since we are looping through that so we can retrieve the qty to allocate from here
'	'Set the SO Line as well

	F.Data.DataTable.SetValue("dtMerge", -1, "Line", V.DataTable.dtPart(V.Local.iLoop).Line!FieldVal, "Open Quantity", V.DataTable.dtPart(V.Local.iLoop).Order Qty!FieldValFloat, "Qty Alloc From Inv", 0, "Qty to Alloc", V.DataTable.dtPart(V.Local.iLoop).Staged Qty!FieldValFloat)
	F.Data.DataTable.Merge("dtMerge", "dtItems", True, 2)
	F.Data.DataTable.Close("dtMerge")	
F.Intrinsic.Control.Next(V.Local.iLoop)
F.ODBC.Connection!con.Close

'Have all of the data by this point to display on the grid so now we can format the grid and add the logic/events when selecting a row and stuff

'Create a dtReset that is an exact copy that is only used to set values back to the original if the user unchecks a row
F.Data.DataTable.AddColumn("dtPart", "Open Quantity", "Float", 0.0)
'V.Passed.000016 is the open quantity on the screen
F.Data.DataTable.SetValue("dtPart", -1, "Open Quantity", V.Passed.000016)

F.Data.DataView.Create("dtPart", "dvPart")
F.Data.DataView.ToDataTable("dtPart", "dvPart", "dtItems", True)
F.Data.DataView.Create("dtItems", "dvItems")

F.Data.DataView.ToDataTable("dtItems", "dvItems", "dtReset", True)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(Error, "Subroutine", V.Ambient.CurrentSubroutine, "ErrorDesc", V.Ambient.ErrorDescription, "ErrorNo", V.Ambient.ErrorNumber)
	F.Intrinsic.Control.EndTry
Program.Sub.LoadData.End

Program.Sub.FormatGrid.Start
F.Intrinsic.Control.Try
V.Local.iVisibleIndex.Declare(Long)
V.Local.iLoop.Declare(Long)
V.Local.iVisibleIndex.Set(-1)
V.Local.sColumns.Declare(String)

F.Intrinsic.String.Split(V.DataTable.dtItems.FieldNames, "*!*", V.Local.sColumns)
Gui.PartForm.GsGCPart.AddGridviewFromDatatable("gvItems", "dtItems")

Gui.PartForm.GsGCPart.SetGridviewProperty("gvItems", V.Enum.GridViewPropertyNames!Multiselect, True)
Gui.PartForm.GsGCPart.SetGridviewProperty("gvItems", V.Enum.GridViewPropertyNames!MultiselectMode, 2)

'Set the column properties - Set all columns to bold
F.Intrinsic.Control.For(V.Local.iLoop, 0, V.Local.sColumns.UBound, 1)
	Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", V.Local.sColumns(V.Local.iLoop), V.Enum.ColumnPropertyNames!HeaderFontBold, True)
F.Intrinsic.Control.Next(V.Local.iLoop)

'Set Column Property - Caption
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Line", V.Enum.ColumnPropertyNames!Caption, "Line")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Part", V.Enum.ColumnPropertyNames!Caption, "Part")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Location", V.Enum.ColumnPropertyNames!Caption, "Loc")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Lot", V.Enum.ColumnPropertyNames!Caption, "Lot")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Bin", V.Enum.ColumnPropertyNames!Caption, "Bin")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Heat", V.Enum.ColumnPropertyNames!Caption, "Heat")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Serial", V.Enum.ColumnPropertyNames!Caption, "Serial")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Qty On Hand", V.Enum.ColumnPropertyNames!Caption, "Qty Avail")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Open Quantity", V.Enum.ColumnPropertyNames!Caption, "Qty Order")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Qty Alloc From Inv", V.Enum.ColumnPropertyNames!Caption, "Qty Current Alloc")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Qty to Alloc", V.Enum.ColumnPropertyNames!Caption, "Qty Left to Alloc")

'Set Column Property - Width
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Line", V.Enum.ColumnPropertyNames!Width, "50")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Part", V.Enum.ColumnPropertyNames!Width, "120")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Location", V.Enum.ColumnPropertyNames!Width, "40")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Lot", V.Enum.ColumnPropertyNames!Width, "60")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Bin", V.Enum.ColumnPropertyNames!Width, "70")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Heat", V.Enum.ColumnPropertyNames!Width, "70")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Serial", V.Enum.ColumnPropertyNames!Width, "80")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Qty On Hand", V.Enum.ColumnPropertyNames!Width, "60")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Open Quantity", V.Enum.ColumnPropertyNames!Width, "60")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Qty Alloc From Inv", V.Enum.ColumnPropertyNames!Width, "60")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Qty to Alloc", V.Enum.ColumnPropertyNames!Width, "60")

'Set Column Property - Allow Edit

'Set the column properties - Set all columns to bold
F.Intrinsic.Control.For(V.Local.iLoop, 0, V.Local.sColumns.UBound, 1)
	Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", V.Local.sColumns(V.Local.iLoop), V.Enum.ColumnPropertyNames!AllowEdit, False)
F.Intrinsic.Control.Next(V.Local.iLoop)
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Qty Alloc From Inv", V.Enum.ColumnPropertyNames!AllowEdit, True)

'Set Column Property - ReadOnly
F.Intrinsic.Control.For(V.Local.iLoop, 0, V.Local.sColumns.UBound, 1)
	Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", V.Local.sColumns(V.Local.iLoop), V.Enum.ColumnPropertyNames!ReadOnly, True)
F.Intrinsic.Control.Next(V.Local.iLoop)
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Qty Alloc From Inv", V.Enum.ColumnPropertyNames!ReadOnly, False)

'Set Column Property - DisplayCustomNumeric
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Qty On Hand", V.Enum.ColumnPropertyNames!DisplayCustomNumeric, "###,###,##0.0000")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Open Quantity", V.Enum.ColumnPropertyNames!DisplayCustomNumeric, "###,###,##0.0000")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Qty Alloc From Inv", V.Enum.ColumnPropertyNames!DisplayCustomNumeric, "###,###,##0.0000")
Gui.PartForm.GsGCPart.SetColumnProperty("gvItems", "Qty to Alloc", V.Enum.ColumnPropertyNames!DisplayCustomNumeric, "###,###,##0.0000")

Gui.PartForm.GsGCPart.MainView("gvItems")

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(Error, "Subroutine", V.Ambient.CurrentSubroutine, "ErrorDesc", V.Ambient.ErrorDescription, "ErrorNo", V.Ambient.ErrorNumber)
	F.Intrinsic.Control.EndTry
Program.Sub.FormatGrid.End

Program.Sub.GsGCPart_CellValueChanged.Start
F.Intrinsic.Control.Try
'Logic to be applied when a row is selected or a quantity to stage is overwritten manually to update the qty. Only for the Qty Alloc From Inv editable column
'Do not need this right now since it kind of defeats the purpose of using the dashboard to do the math for us in some cases, but the flexibility is nice.
V.Local.fQtyAvail.Declare(Float)
V.Local.fQtyCurr.Declare(Float)
V.Local.fQtyRem.Declare(Float)
V.Local.fQtyNewAvail.Declare(Float)
V.Local.fQtyNewRem.Declare(Float)
V.Local.fQtySum.Declare(Float)

V.Local.sPartSelected.Declare(String)
V.Local.sLocSelected.Declare(String)
V.Local.sFilter.Declare(String)
V.Local.sRows.Declare(String)
V.Local.sRowsSplit.Declare(String)

V.Local.iLoop.Declare(Long)

F.Intrinsic.Control.SelectCase(V.Args.Column)
	F.Intrinsic.Control.Case("Qty Alloc From Inv")
	
		Gui.PartForm.GsGCPart.GetCellValueByColumnName("gvItems", "Qty On Hand", V.Args.RowIndex, V.Local.fQtyAvail)
		Gui.PartForm.GsGCPart.GetCellValueByColumnName("gvItems", "Qty Alloc From Inv", V.Args.RowIndex, V.Local.fQtyCurr)
		Gui.PartForm.GsGCPart.GetCellValueByColumnName("gvItems", "Qty to Alloc", V.Args.RowIndex, V.Local.fQtyRem)
		'If the user manually typed something in the Qty Alloc From Inv field, then check to see if that value is valid
		'Does not handle negatives. They need to delete allocations through core
		F.Intrinsic.Control.If(V.Local.fQtyCurr, <, 0)
			F.Intrinsic.UI.Msgbox("Please enter a Qty to Alloc value greater than or equal to 0 in order to save this record.", "Invalid value entered")
			Gui.PartForm.GsGCPart.SetCellValueByColumnName("gvItems", "Qty Alloc From Inv", V.Args.RowIndex, 0)
			F.Intrinsic.Control.ExitSub
		F.Intrinsic.Control.EndIf
		
		'If the user selects a row that doesn't have quantity onhand, tell them they're trolling. Displaying 0 quantity lot/bin records for visibility purposes so they don't think this program isn't pulling them in when they know a lot/bin exists, but doesn't appear on here
		F.Intrinsic.Control.If(V.Local.fQtyAvail, <=, 0)
			F.Intrinsic.UI.Msgbox("Please enter a quantity for a row that has a quantity on hand available that is greater than 0.", "Invalid value entered")
			Gui.PartForm.GsGCPart.SetCellValueByColumnName("gvItems", "Qty Alloc From Inv", V.Args.RowIndex, 0)
			F.Intrinsic.Control.ExitSub
		F.Intrinsic.Control.EndIf
		
		'If the user enters a value greater than what is on hand, tell the user that their inventory would go negative and exit. Do not want to go negative because then we would have to check company options and add a layer of complexity
		F.Intrinsic.Control.If(V.Local.fQtyCurr, >, V.Local.fQtyAvail)
			F.Intrinsic.UI.Msgbox("Please enter a quantity for a row that has a quantity on hand available that is greater than 0.", "Invalid value entered")
			Gui.PartForm.GsGCPart.SetCellValueByColumnName("gvItems", "Qty Alloc From Inv", V.Args.RowIndex, 0)
			F.Intrinsic.Control.ExitSub
		F.Intrinsic.Control.EndIf
		
		'Do the math on the other columns if a positive value is entered here. We are allowing over allocations so we don't have to check for those. Probably leave the Qty left to allocate as a negative if they go over since it doesn't affect anything when we hit save. Just a visual
		F.Intrinsic.Math.Sub(V.Local.fQtyAvail, V.Local.fQtyCurr, V.Local.fQtyNewAvail)
		Gui.PartForm.GsGCPart.SetCellValueByColumnName("gvItems", "Qty On Hand", V.Args.RowIndex, V.Local.fQtyNewAvail)
		
		Gui.PartForm.GsGCPart.GetCellValueByColumnName("gvItems", "Part", V.Args.RowIndex, V.Local.sPartSelected)
		Gui.PartForm.GsGCPart.GetCellValueByColumnName("gvItems", "Location", V.Args.RowIndex, V.Local.sLocSelected)
		
		F.Intrinsic.String.Build("Part = '{0}' and Location = '{1}'", V.Local.sPartSelected, V.Local.sLocSelected, V.Local.sFilter)
		F.Data.DataTable.Compute("dtItems", "Sum(Qty Alloc From Inv)", V.Local.sFilter, V.Local.fQtySum)
		'This is our new sum with the newly entered value
		'Original quantity left to allocate - new sum = Qty left to allocate.
		'Allowing negatives (over allocations)
		F.Intrinsic.Math.Sub(V.DataTable.dtReset(V.Args.RowIndex).Qty to Alloc!FieldValFloat, V.Local.fQtySum, V.Local.fQtyNewRem)
		
		F.Data.DataTable.Select("dtItems", V.Local.sFilter, V.Local.sRows)
		F.Intrinsic.String.Split(V.Local.sRows, "*!*", V.Local.sRowsSplit)
		F.Intrinsic.Control.For(V.Local.iLoop, V.Local.sRowsSplit.LBound, V.Local.sRowsSplit.UBound, 1)
			'Loop through and set Qty Alloc From Inv to the order qty and Qty to Alloc equal to 0 all rows for this part number 
			F.Data.DataTable.SetValue("dtItems", V.Local.sRowsSplit(V.Local.iLoop), "Qty to Alloc", V.Local.fQtyNewRem)
		F.Intrinsic.Control.Next(V.Local.iLoop)
	
		
F.Intrinsic.Control.EndSelect

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(Error, "Subroutine", V.Ambient.CurrentSubroutine, "ErrorDesc", V.Ambient.ErrorDescription, "ErrorNo", V.Ambient.ErrorNumber)
	F.Intrinsic.Control.EndTry
Program.Sub.GsGCPart_CellValueChanged.End

Program.Sub.GsGCPart_RowCellClick.Start
F.Intrinsic.Control.Try
'Logic to be applied when a row is clicked. We want to trigger the calculation of the Qty to Alloc column when the select column (DX$CheckboxSelectorColumn) is selected for a row. This is the first column and is created by a gridview property and not from the datatable so we need to use "GetSelectedRows" based on the grid selected columns and also trigger the math from this.
V.Local.sRowsSplit.Declare(String)
V.Local.sRows.Declare(String)
V.Local.sPartSelected.Declare(String)
V.Local.sLocSelected.Declare(String)
V.Local.sFilter.Declare(String)
V.Local.fQtyAvail.Declare(Float)
V.Local.fQtyNewAvail.Declare(Float)
V.Local.fQtyOrder.Declare(Float)
V.Local.fQtyCurr.Declare(Float)
V.Local.fQtyToAlloc.Declare(Float)
V.Local.fLeftToAlloc.Declare(Float)
V.Local.iLoop.Declare(Long)
V.Local.bSelect.Declare(Boolean)

F.Intrinsic.Control.SelectCase(V.Args.Column)
	F.Intrinsic.Control.Case("DX$CheckboxSelectorColumn")
		
		'Pull all of the values when a row is selected so that we can do some math
		Gui.PartForm.GsGCPart.GetCellValueByColumnName("gvItems", "Part", V.Args.RowIndex, V.Local.sPartSelected)
		Gui.PartForm.GsGCPart.GetCellValueByColumnName("gvItems", "Location", V.Args.RowIndex, V.Local.sLocSelected)
		Gui.PartForm.GsGCPart.GetCellValueByColumnName("gvItems", "Qty On Hand", V.Args.RowIndex, V.Local.fQtyAvail)
		Gui.PartForm.GsGCPart.GetCellValueByColumnName("gvItems", "Open Quantity", V.Args.RowIndex, V.Local.fQtyOrder)
		Gui.PartForm.GsGCPart.GetCellValueByColumnName("gvItems", "Qty Alloc From Inv", V.Args.RowIndex, V.Local.fQtyCurr)
		Gui.PartForm.GsGCPart.GetCellValueByColumnName("gvItems", "Qty to Alloc", V.Args.RowIndex, V.Local.fLeftToAlloc)
		
		'If we just unchecked the row, we need to just set the row back to the original and subtract the amounts out
		'Good thing we have dtReset that contains the original values so we can reverse the logic by unchecking and reset the row

		Gui.PartForm.GsGCPart.GetSelectedRows("gvItems", V.Local.sRows)

		'Check if the row we clicked on is in the selected rows. If it is, then that means we are unchecking this row. Reset this row and subtract the quantity currently allocated from this row to the qty left to allocate column
		F.Intrinsic.String.IsInString(V.Local.sRows, V.Args.RowIndex, False, V.Local.bSelect)
		F.Intrinsic.Control.If(V.Local.bSelect)
			F.Data.DataTable.SetValue("dtItems", V.Args.RowIndex, "Qty On Hand", V.DataTable.dtReset(V.Args.RowIndex).Qty On Hand!FieldValFloat, "Qty Alloc From Inv", 0)
			'We have how much quantity was allocated from this row in the "Qty Alloc From Inv" column. Add that to the "Qty to Alloc" column for all rows for this row
			F.Intrinsic.Math.Add(V.Local.fQtyCurr, V.Local.fLeftToAlloc, V.Local.fQtyToAlloc)						
			F.Intrinsic.String.Build("Part = '{0}' and Location = '{1}'", V.Local.sPartSelected, V.Local.sLocSelected, V.Local.sFilter)
			F.Data.DataTable.Select("dtItems", V.Local.sFilter, V.Local.sRows)
			F.Intrinsic.String.Split(V.Local.sRows, "*!*", V.Local.sRowsSplit)
				F.Intrinsic.Control.For(V.Local.iLoop, V.Local.sRowsSplit.LBound, V.Local.sRowsSplit.UBound, 1)
					'Loop through and set Qty Alloc From Inv to the order qty and Qty to Alloc equal to 0 all rows for this part number 
'					F.Data.DataTable.SetValue("dtItems", V.Local.iLoop, "Qty to Alloc", V.Local.fQtyToAlloc)
					F.Data.DataTable.SetValue("dtItems", V.Local.sRowsSplit(V.Local.iLoop), "Qty to Alloc", V.Local.fQtyToAlloc)
				F.Intrinsic.Control.Next(V.Local.iLoop)
			F.Intrinsic.Control.ExitSub
		F.Intrinsic.Control.EndIf
		
		'Formula
		'Open Quantity - Qty Alloc From Inv = Qty to Alloc (must sum Qty Alloc From Inv for all rows with that part #)
		'Set if Qty On Hand >= Qty to Alloc.
		'Else, Set to Qty On Hand
		
		'If the user manually typed something in the qty to alloc field and they selected this column so that it gets saved, then don't do the math to overwrite. Need a 0 in the Qty to Alloc field in order to perform this calculation. 
		'Does not handle negatives. They need to delete the previous staged shipment if they haven't shipped and invoiced yet=. If they have, then RMA.
		F.Intrinsic.Control.If(V.Local.fQtyCurr, <, 0)
			F.Intrinsic.UI.Msgbox("Please enter a Qty to Alloc value greater than or equal to 0 in order to save this record.", "Invalid value entered")
			Gui.PartForm.GsGCPart.SetCellValue("gvItems", V.Args.ColumnIndex, V.Args.RowIndex, 0)
			F.Intrinsic.Control.ExitSub
		F.Intrinsic.Control.EndIf
		
		'If the user selects a row that doesn't have quantity onhand, tell them they're trolling. Displaying 0 quantity lot/bin for visibility purposes so they don't think this program isn't pulling them in when they know a lot/bin exists, but doesn't appear on here
		F.Intrinsic.Control.If(V.Local.fQtyAvail, <=, 0)
			F.Intrinsic.UI.Msgbox("Please select a row that has a quantity available greater than 0.", "Invalid value selected")
			F.Intrinsic.Control.ExitSub
		F.Intrinsic.Control.EndIf
		
		'Do the actual logic this program is designed to do only if they currently have 0 in the Qty Current to alloc field. Otherwise, we are assuming the user entered a positive value for a reason so we don't want to overwrite what they entered.
		F.Intrinsic.Control.If(V.Local.fQtyCurr, =, 0)
			F.Intrinsic.Control.If(V.Local.fQtyAvail, >=, V.Local.fLeftToAlloc)
				'This is the scenario where if we have enough quantity on hand to fulfill the requirements for this part
				'Set the new Quantity Available for this row, Qty Currently Allocated for this row, and Qty left to alloc for all rows for this part
				F.Intrinsic.Math.Sub(V.Local.fQtyAvail, V.Local.fLeftToAlloc, V.Local.fQtyNewAvail)
				Gui.PartForm.GsGCPart.SetCellValueByColumnName("gvItems", "Qty On Hand", V.Args.RowIndex, V.Local.fQtyNewAvail)
				Gui.PartForm.GsGCPart.SetCellValueByColumnName("gvItems", "Qty Alloc From Inv", V.Args.RowIndex, V.Local.fLeftToAlloc)
				F.Intrinsic.String.Build("Part = '{0}' and Location = '{1}'", V.Local.sPartSelected, V.Local.sLocSelected, V.Local.sFilter)
				F.Data.DataTable.Select("dtItems", V.Local.sFilter, V.Local.sRows)
				F.Intrinsic.String.Split(V.Local.sRows, "*!*", V.Local.sRowsSplit)
				F.Intrinsic.Control.For(V.Local.iLoop, V.Local.sRowsSplit.LBound, V.Local.sRowsSplit.UBound, 1)
					'Loop through and set Qty Alloc From Inv to the order qty and Qty to Alloc equal to 0 all rows for this part number 
					F.Data.DataTable.SetValue("dtItems", V.Local.sRowsSplit(V.Local.iLoop), "Qty to Alloc", 0)
				F.Intrinsic.Control.Next(V.Local.iLoop)
			F.Intrinsic.Control.Else
				'We don't have enough quantity on hand to completely cover the order quantity so we have to just allocate what we have in this lot/bin
				F.Intrinsic.Math.Add(V.Local.fLeftToAlloc, V.Local.fQtyAvail, V.Local.fQtyCurr)
				F.Intrinsic.Math.Sub(V.Local.fLeftToAlloc, V.Local.fQtyAvail, V.Local.fLeftToAlloc)
				Gui.PartForm.GsGCPart.SetCellValueByColumnName("gvItems", "Qty On Hand", V.Args.RowIndex, 0)
				Gui.PartForm.GsGCPart.SetCellValueByColumnName("gvItems", "Qty Alloc From Inv", V.Args.RowIndex, V.Local.fQtyAvail)
				F.Intrinsic.String.Build("Part = {0} and Location = {1}", V.Local.sPartSelected, V.Local.sLocSelected, V.Local.sFilter)
				F.Data.DataTable.Select("dtItems", V.Local.sFilter, V.Local.sRows)
				F.Intrinsic.String.Split(V.Local.sRows, "*!*", V.Local.sRowsSplit)
				F.Intrinsic.Control.For(V.Local.iLoop, V.Local.sRowsSplit.LBound, V.Local.sRowsSplit.UBound, 1)
					'Loop through and set Qty Alloc From Inv to the order qty and Qty to Alloc equal to 0 all rows for this part number 
					F.Data.DataTable.SetValue("dtItems", V.Local.sRowsSplit(V.Local.iLoop), "Qty to Alloc", V.Local.fLeftToAlloc)
				F.Intrinsic.Control.Next(V.Local.iLoop)
			F.Intrinsic.Control.EndIf
		F.Intrinsic.Control.Else
			'This means the user manually entered a quantity and then we triggered this subroutine to update the other lines according to the quantity they entered.
			'First, check that the quantity they entered is less than the quantity remaining to be applied
			
			
		F.Intrinsic.Control.EndIf

F.Intrinsic.Control.EndSelect

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(Error, "Subroutine", V.Ambient.CurrentSubroutine, "ErrorDesc", V.Ambient.ErrorDescription, "ErrorNo", V.Ambient.ErrorNumber)
	F.Intrinsic.Control.EndTry
Program.Sub.GsGCPart_RowCellClick.End

Program.Sub.PartForm_SaveButtonClick.Start
F.Intrinsic.Control.Try
'This happens when the user actually clicks on save
'1 - Take everything that is selected and has a quantity to allocate > 0 and make a dataview
'2 - Modify the BDF to create a new row for each of the records to pass through to it
'3 - Save the BDF and close this grid from the script 1 button
V.Local.sFilter.Declare(String)
V.Local.sRow.Declare(String)
V.Local.sCustomer.Declare(String)
V.Local.sMessage.Declare(String)
V.Local.sColumns.Declare(String)
V.Local.sColumnsNames.Declare(String)
V.Local.bSelected.Declare(Boolean)
V.Local.iLoop.Declare(Long)
V.Local.iCount.Declare(Long, 0)
V.Local.iAllocColumn.Declare(Long)
V.Local.iQtyAvailNewColumn.Declare(Long)
V.Local.iQtyUnpackedColumn.Declare(Long)
V.Local.iQtyBOColumn.Declare(Long)
V.Local.iQtyStagedColumn.Declare(Long)
V.Local.fQtySum.Declare(Float)
V.Local.fQtyAvailCurrent.Declare(Float)
V.Local.fQtyAvailNew.Declare(Float)
V.Local.fQtyStagedCurrent.Declare(Float)
V.Local.fQtyAllocatedCurrent.Declare(Float)
V.Local.fQtyUnpackedCurrent.Declare(Float)
V.Local.fQtyOrderCurrent.Declare(Float)
V.Local.fQtyBOCurrent.Declare(Float)
V.Local.fQtyStagedNew.Declare(Float)
V.Local.fQtyAllocatedNew.Declare(Float)
V.Local.fQtyUnpackedNew.Declare(Float)
V.Local.fQtyBONew.Declare(Float)


F.Data.DataView.Create("dtItems", "dvSelect", 22, "[Qty Alloc From Inv] > 0", "")

'If there aren't any rows that fit this criteria, let the user know and exit the sub with no further action
F.Intrinsic.Control.If(V.DataView.dtItems!dvSelect.RowCount, =, 0)
	F.Intrinsic.UI.Msgbox("No rows with with a quantity greater than 0 were selected to be saved", "Invalid Save")
	F.Intrinsic.Control.ExitSub
F.Intrinsic.Control.EndIf

'Give a message box to let the user know the allocations are processing
F.Intrinsic.UI.InvokeWaitDialog("Allocating Inventory")
V.Local.sCustomer.Set(V.Passed.000058)

F.Intrinsic.Control.For(V.Local.iLoop, 0, V.DataView.dtItems!dvSelect.RowCount--, 1)
	F.Intrinsic.Math.Add(V.Local.iCount, 1, V.Local.iCount)
	F.Intrinsic.String.Build("Allocating Inventory Records {0} out of {1}", V.Local.iCount, V.DataView.dtItems!dvSelect.RowCount, V.Local.sMessage)
	F.Intrinsic.UI.ChangeWaitStatus(V.Local.sMessage, V.Local.iCount, 1, V.DataView.dtItems!dvSelect.RowCount)

	F.Global.Callwrapper.New("Allocate", "Inventory.PartAutoAllocationCustomer")
	F.Global.Callwrapper.SetProperty("Allocate", "Part", V.DataView.dtItems!dvSelect(V.Local.iLoop).Part!FieldValTrim)
	F.Global.Callwrapper.SetProperty("Allocate", "Revision", V.DataView.dtItems!dvSelect(V.Local.iLoop).Rev!FieldValTrim)
	F.Global.Callwrapper.SetProperty("Allocate", "Location", V.DataView.dtItems!dvSelect(V.Local.iLoop).Location!FieldValTrim)
	F.Global.Callwrapper.SetProperty("Allocate", "OrderQuantity", V.DataView.dtItems!dvSelect(V.Local.iLoop).Qty Alloc From Inv!FieldValFloat)
	F.Global.Callwrapper.SetProperty("Allocate", "CustomerNumber", V.Local.sCustomer)
	F.Global.Callwrapper.SetProperty("Allocate", "Lot", V.DataView.dtItems!dvSelect(V.Local.iLoop).Lot!FieldValTrim)
	F.Global.Callwrapper.SetProperty("Allocate", "Bin", V.DataView.dtItems!dvSelect(V.Local.iLoop).Bin!FieldValTrim)
	F.Global.Callwrapper.SetProperty("Allocate", "Heat", V.DataView.dtItems!dvSelect(V.Local.iLoop).Heat!FieldValTrim)
	F.Global.Callwrapper.SetProperty("Allocate", "Serial", V.DataView.dtItems!dvSelect(V.Local.iLoop).Serial!FieldValTrim)
	F.Global.CallWrapper.Run("Allocate")
	
F.Intrinsic.Control.Next(V.Local.iLoop)

'Let the use know that the allocations are complete
F.Intrinsic.UI.ChangeWaitStatus("Updating main screen quantities")

'Loop through the BDF and update the "Allocated" and "Available Quantity" columns according to what was selected from our custom grid
F.Intrinsic.BDF.Load("dtPart", "AUX001", True)
F.Intrinsic.BDF.Clone("dtPart", "dtUpdate")

F.Intrinsic.BDF.ReadColumnTitle("dtPart", V.Local.sColumns)
F.Intrinsic.String.Split(V.Local.sColumns, "*!*", V.Local.sColumns)

F.Intrinsic.Control.For(V.Local.iCount, 0, V.Local.sColumns.UBound, 1)

	Set the column indexes in case the users have moved their columns around
	F.Intrinsic.Control.SelectCase(V.Local.sColumns(V.Local.iCount))
		F.Intrinsic.Control.Case("Allocated")
			V.Local.iAllocColumn.Set(V.Local.iCount)
		F.Intrinsic.Control.Case("Available Qty")
			V.Local.iQtyAvailNewColumn.Set(V.Local.iCount)		
		F.Intrinsic.Control.Case("Staged Qty")
			V.Local.iQtyStagedColumn.Set(V.Local.iCount)
		F.Intrinsic.Control.Case("Unpacked Qty")
			V.Local.iQtyUnpackedColumn.Set(V.Local.iCount)
		F.Intrinsic.Control.Case("BO Qty")
			V.Local.iQtyBOColumn.Set(V.Local.iCount)	
	F.Intrinsic.Control.EndSelect

F.Intrinsic.Control.Next(V.Local.iCount)

V.Local.iQtyStagedColumn.Set(18)
V.Local.iAllocColumn.Set(22)
V.Local.iQtyUnpackedColumn.Set(26)
V.Local.iQtyBOColumn.Set(28)
V.Local.iQtyAvailNewColumn.Set(30)


F.Data.DataView.ToDataTable("dtItems", "dvSelect", "dtSum")

F.Intrinsic.Control.For(V.Local.iLoop, 0, V.DataTable.dtPart.RowCount--, 1)
	'Set allocated to 0 for all rows selected since we already did the allocations through this custom method
	'Set the available quantity to the current available quantity - sum(OrderQuantity) of each record for this part on the custom grid
	'Get sum from custom grid for this part
	F.Intrinsic.String.Build("Part = '{0}' and Location = '{1}'",  V.DataTable.dtPart(V.Local.iLoop).Part Number!FieldValTrim, V.DataTable.dtPart(V.Local.iLoop).Loc!FieldValTrim, V.Local.sFilter)	
	F.Data.DataTable.Compute("dtSum", "Sum(Qty Alloc From Inv)", V.Local.sFilter, V.Local.fQtySum)
	V.Local.fQtyStagedCurrent.Set(V.DataTable.dtPart(V.Local.iLoop).Staged Qty!FieldValFloat)
	V.Local.fQtyOrderCurrent.Set(V.DataTable.dtPart(V.Local.iLoop).Order Qty!FieldValFloat)
	V.Local.fQtyAllocatedCurrent.Set(V.DataTable.dtPart(V.Local.iLoop).Allocated!FieldValFloat)
	V.Local.fQtyUnpackedCurrent.Set(V.DataTable.dtPart(V.Local.iLoop).Unpacked Qty!FieldValFloat)
	V.Local.fQtyBOCurrent.Set(V.DataTable.dtPart(V.Local.iLoop).BO Qty!FieldValFloat)
	V.Local.fQtyAvailCurrent.Set(V.DataTable.dtPart(V.Local.iLoop).Available Qty!FieldValFloat)
	V.Local.bSelected.Set(V.DataTable.dtPart(V.Local.iLoop).Select!FieldValFloat)
	
	'Quantity currently available on the grid - qty we are allocating = new qty available
	F.Intrinsic.Math.Sub(V.Local.fQtyAvailCurrent, V.Local.fQtySum, V.Local.fQtyAvailNew)
	
	'If the column is selected, assume this is the first staged shipment and part allocation for that line so don't change anything. If not selected on the BDF, but quantity entered on the custom screen, then we need to update accordingly, but while considering what was already present on the screen
	F.Intrinsic.Control.If(V.Local.bSelected)
		F.Intrinsic.Control.Next(V.Local.iLoop)
	F.Intrinsic.Control.EndIf
	
	F.Intrinsic.Math.Sub(V.Local.fQtyOrderCurrent, V.Local.fQtyBOCurrent, V.Local.fQtySum, V.Local.fQtyBONew)
	'Don't want a negative BO, but possible if we are over allocating
	F.Intrinsic.Control.If(V.Local.fQtyBONew, <, 0)
		V.Local.fQtyBONew.Set(0)
	F.Intrinsic.Control.EndIf
	'Can overstage so leave this as is if we go over order quantity
	F.Intrinsic.Math.Add(V.Local.fQtyStagedCurrent, V.Local.fQtySum, V.Local.fQtyStagedNew)
	F.Intrinsic.Math.Add(V.Local.fQtyAllocatedCurrent, V.Local.fQtySum, V.Local.fQtyAllocatedNew)
	F.Intrinsic.Math.Add(V.Local.fQtyUnpackedCurrent, V.Local.fQtySum, V.Local.fQtyUnpackedNew)
	
'	F.Data.DataTable.SetValue("dtPart", V.Local.iLoop, "Allocated", 0, "Available Qty", V.Local.fQtyAvailNew)
	F.Data.DataTable.SetValue("dtPart", V.Local.iLoop, "Staged Qty", V.Local.fQtyStagedNew, "Allocated", V.Local.fQtyAllocatedNew, "Unpacked Qty", V.Local.fQtyUnpackedNew, "BO Qty", V.Local.fQtyBONew, "Available Qty", V.Local.fQtyAvailNew)
	
	F.Intrinsic.BDF.SetData("dtPart", V.Local.iAllocColumn, V.Local.iLoop, V.Local.fQtyAllocatedNew)
	F.Intrinsic.BDF.SetData("dtPart", V.Local.iQtyAvailNewColumn, V.Local.iLoop, V.Local.fQtyAvailNew)
	F.Intrinsic.BDF.SetData("dtPart", V.Local.iQtyStagedColumn, V.Local.iLoop, V.Local.fQtyStagedNew)
	F.Intrinsic.BDF.SetData("dtPart", V.Local.iQtyUnpackedColumn, V.Local.iLoop, V.Local.fQtyUnpackedNew)
	F.Intrinsic.BDF.SetData("dtPart", V.Local.iQtyBOColumn, V.Local.iLoop, V.Local.fQtyBONew)

	'Have everything updated in the datatable from the BDF so now go back and write this back to the cloned BDF and save it back
	
	F.Intrinsic.BDF.ReadRow("dtPart", V.Local.iLoop, V.Local.sRow)
	F.Intrinsic.BDF.WriteRow("dtUpdate", V.Local.sRow)
	
F.Intrinsic.Control.Next(V.Local.iLoop)

F.Intrinsic.BDF.Save("dtUpdate", "AUX001")

F.Intrinsic.UI.Msgbox("Allocating Complete!", "Success")
F.Intrinsic.UI.CloseWaitDialog

'Exit the program and go back to the main screen
F.Intrinsic.Control.End

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(Error, "Subroutine", V.Ambient.CurrentSubroutine, "ErrorDesc", V.Ambient.ErrorDescription, "ErrorNo", V.Ambient.ErrorNumber)
	F.Intrinsic.Control.EndTry
Program.Sub.PartForm_SaveButtonClick.End

Program.Sub.Serialize.Start
F.Intrinsic.Control.Try

'Serialize subroutine that saves format and saves it to the registry table in Zen
V.Local.sSerialize.Declare
Gui.PartForm.GsGCPart.Serialize("gvItems", V.Local.sSerialize)
F.Global.Registry.AddValue(V.Caller.User, V.Caller.CompanyCode, "gvItems", 7638, 9999, False, "Serialize", False, 0, 0, V.Ambient.Date, V.Ambient.Time, V.Local.sSerialize)

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub("Error", "Subroutine", V.Ambient.CurrentSubroutine, "ErrorDesc", V.Ambient.ErrorDescription, "ErrorNo", V.Ambient.ErrorNumber)
	F.Intrinsic.Control.EndTry
Program.Sub.Serialize.End

Program.Sub.DeSerialize.Start
F.Intrinsic.Control.Try

'Deserialize subroutine that loads format that was added to the registry from the serialize
'Also apply saved settings so the form loads in the same way it was closed
V.Local.sSerialize.Declare
F.Global.Registry.ReadValue(V.Caller.User, V.Caller.CompanyCode, "gvItems", 7638, 9999, 6, "", V.Local.sSerialize)
F.Intrinsic.Control.If(V.Local.sSerialize, <>, "")
	Gui.PartForm.GsGCPart.AddGridviewFromDatatable("gvItems", "dtItems")
	Gui.PartForm.GsGCPart.MainView("gvItems")
	Gui.PartForm.GsGCPart.Deserialize(V.Local.sSerialize)
F.Intrinsic.Control.Else
	F.Intrinsic.Control.CallSub("FormatGrid")	
F.Intrinsic.Control.EndIf

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub("Error", "Subroutine", V.Ambient.CurrentSubroutine, "ErrorDesc", V.Ambient.ErrorDescription, "ErrorNo", V.Ambient.ErrorNumber)
	F.Intrinsic.Control.EndTry
Program.Sub.DeSerialize.End

Program.Sub.PartForm_UnLoad.Start
F.Intrinsic.Control.Try

'Serialize the grid if it exists
'Close the datatable if it is open
F.Intrinsic.Control.If(V.DataTable.dtItems.Exists)
	F.Intrinsic.Control.CallSub("Serialize")
	F.Data.DataTable.Close("dtItems")
F.Intrinsic.Control.EndIf

'Close the ODBC connection if it is open
F.Intrinsic.Control.If(V.ODBC.con.Exists, =, True)
	F.ODBC.Connection!con.Close
F.Intrinsic.Control.EndIf

'End the program
F.Intrinsic.Control.End

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.CallSub(Error, "Subroutine", V.Ambient.CurrentSubroutine, "ErrorDesc", V.Ambient.ErrorDescription, "ErrorNo", V.Ambient.ErrorNumber)
	F.Intrinsic.Control.EndTry
Program.Sub.PartForm_UnLoad.End

Program.Sub.Error.Start
F.Intrinsic.Control.Try
V.Local.sError.Declare(String)

F.Intrinsic.String.Build("Project: {0}{1}{1}Subroutine: {2}{1}Error Occurred {3} with description {4}{1}{1}GAB Version: {5}", V.Caller.ScriptFile, V.Ambient.Newline, V.Args.Subroutine, V.Args.ErrorNo, V.Args.ErrorDesc, V.Ambient.GABVersion, V.Local.sError)
F.Intrinsic.UI.Msgbox(V.Local.sError, "Error")

F.Intrinsic.Control.Catch
	F.Intrinsic.Control.End
	F.Intrinsic.Control.EndTry
Program.Sub.Error.End

Program.Sub.Comments.Start
${$5$}$20.1.9039.19491$}$1
${$6$}$gsandoval$}$20241108113309165$}$pxyipsmdqasyAY7lJ5+YqAibKN4I37/YXQ2byAA0xDFW4A1CRYhwrF4Twk21jVjRDMPuWvUTj6cGbKqyZIGRsg==
${$7$}$File Version:1.1.20241108173309.0

Program.Sub.Comments.End
